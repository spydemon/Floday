\newglossaryentry{action}{
	name=action,
	plural=actions,
	description={%
		Une action consiste en un procédé actif réalisé par \emph{Floday} dans le cadre du déploiement.
		Elles peuvent être des exécutions de commandes, des écritures de configuration, ou de toute autres formes prévues par la définition du \gls{conteneur} en cours d'\gls{instantiation}.
	}
}

\newglossaryentry{application}{
	name=application,
	plural=applications,
	description={%
		Service concret rendu par le système informatique de référence, résultant du déploiement d'un \gls{conteneur}.
		C'est l'entité pour laquelle \emph{Floday} existe~: le processus final utilisé par les clients.
		Exemple~: un blog, un serveur \emph{Mumble}, un service de messagerie instantanée.
	}
}

\newglossaryentry{attribut}{
	name=attribut,
	plural=attributs,
	description={%
		L'attribut est une entité d'information permettant de définir un \gls{conteneur}.
		Il peut avoir des formes très variés, et se situent généralement au sein de la configuration d'un conteneur.
		Il ont également des formes hiérarchiques~: un attribut peut en contenir d'autres.
		De façon générale, les attributs peuplent intégralement les fichiers \emph{config.yml} présents au cœur de chaque conteneur.
	}
}

\newglossaryentry{chemin_application}{
	name={chemin d'application},
	plural={chemins d'applications},
	description={%
		Défini le nom concrêt d'une application en fonction de l'\gls{imbrication} de ses \glspl{gestionnaire}.
		Un tiret est utilisé pour séparer les différentes imbrications.
		Par exemple, on peut avoir~: \emph{spyzone-web-my\_blog} pour une application nommée \emph{my\_blog} contraint par \emph{web} sur l'hôte \emph{spyzone}.
		Il s'agit ici d'une notion similaire à celle du \gls{chemin_conteneur}, mais avec le nom de l'application à la place du type de conteneur.
	}
}

\newglossaryentry{chemin_conteneur}{
	name={chemin de conteneur},
	plural={chemins de conteneurs},
	description={%
		Défini le type concrêt d'un conteneur en fonction de l'\gls{imbrication} de ses \glspl{gestionnaire}.
		Un tiret est utilisé pour séparer les différentes imbrications.
		Par exemple, on peut avoir~: \emph{riuk-web-wordress} pour un conteneur \emph{wordpress} contraint par \emph{web} dans le \gls{jeu_conteneur} \emph{riuk}.
		Il s'agit ici d'une notion similaire à celle du \gls{chemin_application}, mais avec le type de conteneur à la place du nom de l'application.
	}
}

\newglossaryentry{conteneur}{
	name=conteneur,
	plural=conteneurs,
	description={%
		Le conteneur est une recette à appliquer pour produire une \gls{application}.
		Un même conteneur peut donc être utiliser pour générer plusieurs applications similères.
		Par exemple~: un conteneur \emph{Wordpress} peut être utiliser pour générer plusieurs blogs.
	}
}

\newglossaryentry{sous-conteneur}{
	name=sous-conteneur,
	plural=sous-conteneurs,
	text=sous-conteneur,
	description={%
		Un sous-conteneur est un conteneur dont son propre fonctionnement est conditionné par un autre, appelé conteneur \gls{gestionnaire}.
		Ce terme permet d'établir la hiérarchie entre les différents conteneurs. Exemple~: \emph{spyzone-web-wordpress}. Ici, \emph{wordpress} est un sous-conteneur de
		\emph{web}. Ça signifie que \emph{web} aura, dans la propre définition, des actions à prendre en fonction de ses sous-applications (une configuration adéquat
		au niveau du serveur Web, par exemple).
	}
}

\newglossaryentry{sous-application}{
	name=sous-application,
	plurial=sous=applications,
	text=sous-application,
	description={%
		Une sous-application représente une instance de \gls{sous-conteneur}. Il ne s'agit là aussi que d'un terme permettant utile à la clarification de la hiérarchie entre les applications.
	}
}

\newglossaryentry{definition}{
	name=définition -- de conteneurs,
	text=définition,
	description={%
		Une définition de conteneur présente la façon dont le conteneur doit se déployer.
		Il s'agit d'y définir les scripts à exécuter, dans quel ordres, ainsi que touts autres éléments nécessaires, comme la création des attributs.
		Cette définition s'effecute dans les fichiers {\tt{}config.yml} du conteneur courant, de ceux de ses parents ainsi que du \gls{runfile} (pour les attributs surchargés).
	}
}

\newglossaryentry{deploiement}{
	name=déploiment -- d'applications,
	text=déploiment,
	plural=déploiments,
	description={%
		Le déploiment est l'action permettant de transformer la \gls{definition} d'un conteneur en \gls{application}.
		Il est généralement constitué de deux étapes principales~: l'\gls{initialisation} et l'itération des différents scripts d'installation présent au niveau de la \gls{definition} du conteneur en question.
	}
}

\newglossaryentry{gestionnaire}{
	name=gestionnaire -- de conteneurs,
	text=gestionnaire,
	plural=gestionnaires,
	description={%
		Un \gls{conteneur} est gestionnaire s'il manage ou permet à d'autre conteneurs de fonctionner au travers lui.
		Un gestionnaire s'occupe de ses \glspl{sous-conteneur}.
	}
}

\newglossaryentry{hote}{
	name=hôte,
	plural=hôtes,
	description={%
		L'hôte et le niveau zéro de l'\gls{imbrication}.
		Il s'agit du système physique sur lequels les \glspl{application} sont executées.
		Les \glspl{action} qui y sont effectues n'ont donc aucun confinement.
	}
}

\newglossaryentry{imbrication}{
	name=imbrication,
	description={%
		L'imbrication représente un niveau de hiérarchie entre les \glspl{sous-application} et les \glspl{gestionnaire}.
		L'imbrication zéro représente l'\gls{hote} sur lequel les applications s'exécute.
		Une application d'imbrication deux signifie qu'elle est contrainte par une autre application présente entre elle-même et l'hôte.
		Par exemple~: \emph{host-web-wordpress}.
	}
}

\newglossaryentry{initialisation}{
	name=initialisation,
	description={%
		Il s'agit du minimum à effectuer pour permettre le déploiment d'une \gls{application} fonctionnelle, c'est-à-dire généralement, avoir un \emph{OS} minimaliste permettant les fonctionnalités de base.
		Actuellement, les seules initialisations de supportées le sont via des templates \emph{LXC}.
		Concrètement, il s'agit donc d'exécuter la commande {\tt{}lxc-deploy} avec le bon template (\emph{flodayalpine} est fourni par défaut).
		Comme son nom l'indique, il se contente de créer un conteneur \emph{Alpine Linux} minimaliste.
		Actuellement, l'initialisation à utiliser pour chaque \gls{conteneur} est défini à l'aide du \gls{param_applicatifs} \emph{template}.
	}
}

\newglossaryentry{instantiation}{
	name=instantiation,
	plural=instantiation,
	description={%
		Installation d'une \gls{application}.
		C'est-à-dire qu'on déroule tous les scripts d'exécution pour mettre en place l'application et la rendre utilsable.
	}
}

\newglossaryentry{jeu_conteneur}{
	name=jeu de conteneurs,
	plural=jeux de conteneurs,
	description={%
		Le jeu de conteneurs constitue la définition même de ce que \emph{Floday} est capable de déployer.
		Par défaut, le jeu doit être présent dans le répertoire {\tt/etc/floday/containers}.
		Il est à la charge de l'utilisateur d'écrire son propre jeu, car seul lui est à-même de savoir comment son architecture devrait fonctionner.
	}
}

\newglossaryentry{param_applicatifs}{
	name=paramètre applicatif,
	plural=paramètres applicatifs,
	description={%
		Un paramètre applicatif est une entité de configuration appliquée à une \gls{application}.
		Il peut être implicite, si il est défini au niveau de la définition du \gls{conteneur} ou explicite, si il l'est plutôt au niveau du \gls{runfile}.
		Il peut aussi être redéfini à chaque niveau~: dans un conteneur hérité, fils puis dans le runfile.
		Comme exemple, nous pouvons prendre le cas d'un paramètre \emph{url} présent dans le conteneur \emph{Wordpress} permettant de savoir comment configurer correctement le \emph{CMS}.
	}
}

\newglossaryentry{propulse}{
	name=propulsion -- de version,
	plural=propulsées,
	text=propulsée,
	description={%
		On parlera de propulsion de version l'action de stopper les développements en cours et de les publier. Par exemple, nous pouvons dire~:
		\begin{itemize}
			\item La branche \emph{développement} propulsera la prochaine version majeure.
			\item La branche \emph{bugsfix1.2} propulsera la nouvelle version \emph{v1.2.z}.
		\end{itemize}
		Le terme peut également être utilisé pour indiquer dans quelles versions se situent un ticket, ou une fonctionnalité précise. Nous pouvons dire~:
		\begin{itemize}
			\item Les corrections \#3, \#4 et \#5 seront propulsés dans la \emph{v1.2.4} et la \emph{v1.3.0}.
			\item La fonctionnalité de parsage dynamique de la configuration sera propulsé dans la \emph{v1.4}.
		\end{itemize}
	}
}

\newglossaryentry{runfile}{
	name=runfile,
	description={%
		Par défaut à l'emplacement {\tt/etc/runfile}, il s'agit du fichier définissant explicitement toutes les \glspl{application} a exécuter sur l'ensemble du «\,parc\,» informatique géré.
		Le même fichier est donc utilisé sur plusieurs hôtes pour permettre là encore de voir les interactions (procédés de backup, ou de répartion de la charge, etc.).
		Il contient donc une liste exaustive de toutes les applications à déployer, ainsi que la liste de tous les \glspl{param_applicatifs} non implicites.
	}
}

\newglossaryentry{runlist}{
	name=runlist,
	description={%
		Il s'agit d'un composant interne à \emph{Floday} utilisé pour représenter de façon la plus simple possible (via un tableau multi-dimentionnel) tout ce qui constitue une application.
		C'est à dire l'ensemble de sa définition une fois tous les procédés d'héritages et de réécritures effectués.
	}
}
