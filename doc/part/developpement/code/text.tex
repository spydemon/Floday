\subsection{Apporter des modifications au code source}

Une fois que vous accédez au code source de l'application, vous pouvez bien-entendu en faire ce que vous voulez.
Si participer à l'évolution vous intéresse, vous êtes encouragé à me faire des pull requests que je mergerais dans le dépôt principal si votre travail répond correctement à un ticket \emph{accepté}.

N'ayant jamais eu à effectuer ce genre d'actions pour le moment, je ne suis pas sûr qu'il s'agisse de la meilleure façon de faire, ni même qu'elle soit réellement pratique sur le long terme, mais on aura toujours l'occasion de changer ça une fois ce logiciel massivement maintenu \Winkey.

\subsubsection{Convention de code}
Voici les brèves consignes à appliquer, dans un soucis de cohérence si vous comptez participer à l'écriture du code source~:
\begin{itemize}
	\item Les commentaires ainsi que les variables doivent être écrits en anglais.
	\item On utilise le \emph{snake\_case}.
	\item Une tabulation est utilisée pour l'indentation.
	\item Deux espaces sont utilisées pour les brisements de lignes.
	\item La virgule touche touche toujours un caractère à gauche, et a un espace ou un saut de ligne à droite.
	\item On ne saute pas de ligne avant l'accolade ouvrante.
	\item Une parenthèse, accolade ou crochet fermant doit toujours être au même niveau d'indentation que son binôme ouvrant. 
\end{itemize}

Le listing~\ref{fig_3.1_conventions} est un exemple permetant d'illustrer l'histoire de l'indentation et du brisements de lignes.
Les boules grises représentent des espaces, et les flèches une indentation.

\begin{lstlisting}[basicstyle=\normalsize, caption={Conventions de code}, label=fig_3.1_conventions]
sub write_stuff(
~{\color{gray}$\bullet\bullet$}~$param_one,
~{\color{gray}$\bullet\bullet$}~$param_two
) {
~{\color{gray}--->}~print "$param_one $param_two";
}
\end{lstlisting}

\subsubsection{Workflow \emph{Git}}

\paragraph{Les types de branches}
La figure~\ref{fig_3.2_git} (qui est moche pour le moment, mais sera refaite avec \emph{TikZ} un jour) ilustre de façon plus visuelle les explications ci-dessous.
Notez qu'il manque néanmoins la branche \emph{master} et les branches \emph{relase} sur celle-ci.

Attention, pour le moment il s'agit d'un workflow plutôt théorique et qui reste très confu\dots Je n'ai en effet pas encore eu l'occasion de le mettre en pratique. Celui-ci est donc suceptible de changer~!

\begin{description}
	\item[Branche \emph{master}]
		Elle pointera toujours sur la dernière version stable.
		Même si cela nécessite un changement de version majeure.
	\item[Branche \emph{development}]
		C'est sur celle-ci qu'on mergera les tickets relatifs à la prochaine version mineure ou majeure en cours de développement.
		Quand ceux-ci sont terminés, une nouvelle branche stable sera crée depuis celle-ci, ainsi que la branche \emph{bugsfix} correspondante.
	\item[Branches stables]
		Une branche est créée pour chaque version majeure et mineure du logiciel. Ces branches doivent être utilisées en production, elles permettent de toujours trouver la dernière release pour la version désirée.
	\item[Branches bugsfix]
		Permettent la préparation des correctifs.
		Une branche \emph{bugsfix} n'existe que avant la publication d'une nouvelle version de correctifs.
		Quand nous estimons que cette branche contient suffisamment d'éléments pour justifier une nouvelle release, elle sera mergée sur la branche stable correspondante, incrémentant ainsi le numéro \emph{z} de sa version, correspondant au correctif.
		La branche pourra ensuite être supprimée et recrée à partir de la nouvelle version mineure si besoin est.
	\item[Branches d'implémentations]
		Une branche d'implémentation doit être crée pour chaque tickets.
		La base de cette branche dépendra du type de ticket, on en parle dans un paragraphe sous-jacent.
		Une fois les développements réalisés et mergés au bon endroit, nous pouvons supprimer la branche pour éviter de polluer le git avec des branches obsolètes.
		Deux types de branches d'implémentation existent~:
		\begin{description}
			\item[Implémentation de fonctionalités]
				Ces branches partent de l'état courant de \emph{master}.
				Elles sont a utiliser pour l'accomplissement d'un ticket d'évolution, donc qui ajoute une fonctionnalité ou change une méthode de fonctionnement.
				Une fois le dévelopement considéré comme terminé, la branche pourra être mergée dans \emph{developement}.
				Si après ce merge, on s'apperçoit d'un bug ou d'une régression entrainée par l'évolution, il faudra continuer à publier les correctifs sur cette branche, puis la remerger dans \emph{development}.
				Attention à bien conserver la branche jusqu'à ce qu'elle soit mergée sur une nouvelle branche stable.
			\item[Implémentation de correctifs]
				Ces branches partent de la première version stable a présenter le problème.
				Une fois le problème de réparé, elle sera mergée dans les branche \emph{bugfix} de chaques version stable présentant l'anomalie, voir dans \emph{development} si elle monte aussi haut.
				Idéalement, le correctif devrait donc se présenté sous la forme d'un seul commit, ce qui rend facile le \emph{cherry-pick}.
		\end{description}
\end{description}

\paragraph{Procédure de merge}
De façon générale, les messages de commit doivent être écrits en anglais. \emph{Git} doit aussi être correctement configuré pour que le nom et l'adresse email de l'utisateur soient les bons.
Une fois une branche de développement prête à être mergée sur une branche \emph{bugfix} ou sur \emph{development}, le commit de merge devra avoir un message dont la première ligne ressemble à~:\\
{\tt[<signe\_ticket>] \#<numéro\_ticket>: <description>.}\\
Avec~:
\begin{itemize}
	\item\emph{<description>} -- doit commencer par une minuscule, et décrire de façon concise ce qui a été réalisé dans le commit.
	\item\emph{<signe\_ticket>} -- le signe du ticket dépend grandement du type de branche sur laquelle nous sommes.
\end{itemize}
Si le message de commit mérite de plus amples informations, on pourra marquer ce texte après avoir sauter une ligne entre celui-ci, et la première ligne dont on parle ci-dessus.
	Le signe du ticket peut ici avoir trois états différents~:
		\begin{itemize}
			\item {\tt+} en cas de traitement d'une évolution.
			\item {\tt-} en cas de correction d'anomalie publiée.
			\item {\tt*} en cas de correction d'anomalie d'évolution (évolution déjà mergée dans \emph{development} mais qui nécessite un nouveau merge à cause d'une regression).
		\end{itemize}
Voici des indications plus précises concernant les branches en fonction de leurs types~:
\begin{description}
	\item[Branches d'implémentations]
		N'oubliez pas qu'il s'agit là des seules branches pouvant réellement avoir du contenu applicatif.
		Les messages de commits peuvent ici avoir une forme assez libre.
		Comme d'habitude, privilégiez de petits commits, dont leurs messages explique l'action contrète réalisée.
	\item[Branche \emph{development}]
		Une fois une fonctionnalité mature sur sa branche d'implémentation, elle peut être mergée sur \emph{development}.
		À ce moment, la branche d'implémentation en question ne doit pas être supprimé car le pointeur sera nécessaire pour merger la fonctionnalité sur une branche stable.
		Notez que ce merge doit être fait avec l'option \emph{--no-ff} pour éviter de n'avoir qu'un simple déplacement de pointeur au niveau de \emph{Git} sans avoir de commit de merge explicite.\\

		Le message de ce commit peut avoir la forme générique présentée ci-dessus, avec un {\tt+} ou {\tt*} comme signe de ticket.
	\item[Branches de release et branches stables]
		Une fois des développements sufisamment testés sur la branche \emph{development}, une nouvelle version pourra être publiée incluant toutes les évolutions validées.
		Il s'agira soit d'une incrémentation de version mineure si la rétro-compatilibité n'est pas brisée, soit une branche incrémentation de la version majeur si c'est le cas.
		Dans le cas d'une incrémentation mineure, n'oubliez pas d'également merger la nouvelle branche dans la branche stable correspondant à la version majeure concernée.\\

		Concrètement parlant, on crééra ici une nouvelle branche depuis une branche stable que l'on veut voir évoluer (une branche majeure ou mineur) qui s'appellera \emph{release-vx.y.0}. Sur cette branche nous mergerons toutes les branches d'implémentations que l'on désire inclure dans cette nouvelle version.
		Finalement, on créera un nouveau commit (vide ? (option \emph{allow-empty})) à la tête de celle-ci, ayant comme première ligne sur le message de commit~:\\
		{\tt[RELEASE] vx.y.0}\\
		Avec \emph{x} et \emph{y} qui représente le nouveau numéro de version (\emph{z} sera forcément à zéro).
		Les autres lignes peuvent être un rapide changelogs des différents tickets intégrés à l'évolution.\\
		Si le package que représente cette branche fonctionne bien, la release sera validée, et un merge avec l'option \path{no-ff} sur la branche stable pourra être effectué.
		Nous pouvons finallement supprimer la branche de release.

		Depuis ce commit, un tag sera créé avec le même numéro de version(\path{git tag -m x.y.0 -a x.y.0}), mais sans le préfixe \emph{v}.
	\item[Branches bugfixs]
		Une branche \emph{bugfix} devra être crée en parallèle de chaque version stable.
		Elle se chargera d'aggréger les branches d'implémentation correspondant à des corrections à apporter par la version stable concernée.
		Le changelog ne devra présenter que correctifs publiés.
		Notons qu'il ne devrait de toute façon rien avoir d'autre de modifié.\\

		Quand la branche \emph{bugfix} est freezée pour lui permettre une intégration dans la branche stable concernée, elle sera mergée avec comme message de commit {\tt[RELEASE] vx.y.z} dans la branche stable à laquelle est est liée.
		À présent, cette branche \emph{bugfix} pourra être supprimée et pourra être recrée depuis cette nouvelle version stable pour accueillir les nouveaux correctifs.
\end{description}

\begin{figure}
	\centering
	\includegraphics[scale=0.3]{part/developpement/code/fig_workflow_git.png}
	\caption{Workflow git}
	\label{fig_3.2_git}
\end{figure}
