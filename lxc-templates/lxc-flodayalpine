#!/usr/bin/env perl

use v5.010;
use warnings FATAL => 'all';
use strict;

use Backticks;
use Carp;
use Config::Tiny;
use File::Slurp;
use Getopt::Long;

$Backticks::autodie = 1;

my $CACHE_FOLDER = '/tmp/floday/lxc-flodayalpine';

my ($LXC_PATH, $LXC_NAME, $LXC_ROOTFS);
GetOptions("path=s" => \$LXC_PATH,
  "name=s" => \$LXC_NAME,
  "rootfs=s" => \$LXC_ROOTFS
);

my %templateArguments= (@ARGV);

sub deployAPKIndex {
	if (!-d "$CACHE_FOLDER/apkIndex") {
		my $APKArchive = getFile('APKINDEX.tar.gz');
		`mkdir -p $CACHE_FOLDER/apkIndex`;
		`tar -xf $APKArchive -C $CACHE_FOLDER/apkIndex`;
	}
	return "$CACHE_FOLDER/apkIndex/APKINDEX";
}

sub generateLXCConfiguration{
	#TODO : Apply restriction by apparmor and seccomp.
	my $id = getUserId();
	my $range = getFlodayConfigurationValue('id_range');
	open(my $configurationFile, '>', "$LXC_PATH/config");
	my @configurationEntries = (
	  "lxc.id_map = u 0 $id $range",
	  "lxc.id_map = g 0 $id $range",
	  "lxc.mount.auto = proc:mixed",
	  "lxc.mount.entry = $CACHE_FOLDER/apk $LXC_ROOTFS/etc/apk/cache none bind 0.0",
	  "lxc.network.type = veth",
	  "lxc.network.flags = up",
	  "lxc.network.link = lxcbr0",
	  "lxc.rootfs = $LXC_ROOTFS",
	  "lxc.utsname = $LXC_NAME"
	);
	say{$configurationFile} $_ foreach @configurationEntries;
}

sub getAlpineVersionToUse {
	'v' . $templateArguments{version} if $templateArguments{version} =~ /^[0-9]{1,2}\.[0-9]{1}$/
	  or die "The version of alpine to use is mandatory";
}

sub getArchitectureToUse {
	$templateArguments{architecture} // 'x86_64';
}

sub getFile {
	my ($packageName) = @_;
	my $repositoryAddress = getMainRepositoryAddress() . '/' . getArchitectureToUse();
	my $pathForDownloadedFile = "$CACHE_FOLDER/files";
	if (!-f "$pathForDownloadedFile/$packageName") {
		`wget -q -P $pathForDownloadedFile $repositoryAddress/$packageName`;
	}
	return "$pathForDownloadedFile/$packageName";
}

sub getFlodayConfigurationValue {
	my ($attribute) = @_;
	state $config = Config::Tiny->read('/etc/floday/floday.cfg');
	my $property = $config->{lxc}->{$attribute};
	if (!defined $property) {
		croak("The property lxc/$attribute was asked but is not defined in Floday configuration file");
	}
	return $property;
}

sub getPackage {
	my ($target) = @_;
	my $index = read_file(deployAPKIndex());
	while (
	  $index =~ /
	    ^P:(?P<name>.*)\n		#Get the next software name present in the index.
	    ^V:(?P<version>.*)\n	#Get the next software version present in the index.
	  /mgx
	) {
		if ($+{name} eq $target) {
			return getFile("$+{name}-$+{version}.apk");
		}
	}
	die("Package $target was not found in APKIndex");
}

sub getUserId {
	#TODO: manage collisions
	my $range = getFlodayConfigurationValue('id_range');
	my $groups = getFlodayConfigurationValue('id_groups');
	state $id = int(rand($groups)+1) * $range + $range;
}

sub getMainRepositoryAddress {
	'https://wiki.alpinelinux.org/cgi-bin/dl.cgi/' . getAlpineVersionToUse() . '/main/';
}

sub initSystem {
	my $apkRepoToUse = getMainRepositoryAddress();
	my $arch = getArchitectureToUse();
	`mkdir -p $CACHE_FOLDER/apk && chmod a+rw $CACHE_FOLDER/apk && ln -s $CACHE_FOLDER/apk $LXC_ROOTFS/etc/apk/cache `;
	`echo $apkRepoToUse > $LXC_ROOTFS/etc/apk/repositories`;
	#TODO: update of repo only when needed.
	open (my $fh, '-|', "$LXC_ROOTFS/sbin/apk.static -U add --initdb --root $LXC_ROOTFS --arch $arch alpine-base");
	print $_ while(<$fh>);
}

sub installPackage {
	my ($packageName) = @_;
	my $packagePath = getPackage($packageName);
	`tar -xf '$packagePath' -C '$LXC_ROOTFS' 2>/dev/null`;
	$packageName =~ s/\W//g;
	if (defined &{"_installPackage_$packageName"}) {
		no strict 'refs';
		&{"_installPackage_$packageName"}();
	}
}

sub manageSystemConfiguration {
	my $id = getUserId();
	`rm $LXC_ROOTFS/etc/apk/cache && mkdir -p $LXC_ROOTFS/etc/apk/cache`;
	#TODO : resolv.conf should be provided in container instantation.
	`cp /etc/resolv.conf $LXC_ROOTFS/etc/resolv.conf`;
	`chmod 750 $LXC_PATH`;
	`chown :$id $LXC_PATH`;
	`chown -R $id:$id $LXC_ROOTFS`;
}

sub _installPackage_alpinekeys {
	my %keys = (
	  'alpine-devel@lists.alpinelinux.org-4a6a0840.rsa.pub' => '9c102bcc376af1498d549b77bdbfa815ae86faa1d2d82f040e616b18ef2df2d4',
	  'alpine-devel@lists.alpinelinux.org-4d07755e.rsa.pub' => '2adcf7ce224f476330b5360ca5edb92fd0bf91c92d83292ed028d7c4e26333ab',
	  'alpine-devel@lists.alpinelinux.org-5243ef4b.rsa.pub' => 'ebf31683b56410ecc4c00acd9f6e2839e237a3b62b5ae7ef686705c7ba0396a9',
	  'alpine-devel@lists.alpinelinux.org-524d27bb.rsa.pub' => '1bb2a846c0ea4ca9d0e7862f970863857fc33c32f5506098c636a62a726a847b',
	  'alpine-devel@lists.alpinelinux.org-5261cecb.rsa.pub' => '12f899e55a7691225603d6fb3324940fc51cd7f133e7ead788663c2b7eecb00c'
	);
	my $keyList = `echo $LXC_ROOTFS/etc/apk/keys/*.pub`;
	my $keyChecked = 0;
	while ($keyList =~ /
	    (?P<keyPathToUse>.*?                    #keyPathToUse will contain the absolute path of the next key.
	      (?P<keyNameToUse>alpine-devel.*?)     #keyNameToUse will contain only the name of the next key.
	    )
	  \s/gx
	) {
		`cd $LXC_ROOTFS/etc/apk/keys && echo "$keys{$+{keyNameToUse}} $+{keyNameToUse}" | sha256sum -c -`;
		$keyChecked += 1;
	}
	die ('Too much key signatures are in this template') if ($keyChecked != keys %keys);
}

sub _installPackage_apktoolsstatic {
	`echo $LXC_ROOTFS/sbin/apk.static.*.pub`         #Get the path of the file corresponding to apk.static signed hash.
	  =~ /
	    (?P<signatureToCheck>^.*                 #Capture the absolute path without the \n at the end of the line.
	      (?P<keyToUse>alpine-devel[^\/]*)       #The name of the key used for the signature is present in the hash name.
	    )
	  \s$/x;
	my $fileToCheck = "$LXC_ROOTFS/sbin/apk.static";
	my $keyToUseForChecking = "$LXC_ROOTFS/etc/apk/keys/$+{keyToUse}";
	`openssl dgst -sha1 -verify $keyToUseForChecking -signature $+{signatureToCheck} $fileToCheck`;
}

installPackage('alpine-keys');
installPackage('apk-tools-static');
initSystem();
generateLXCConfiguration();
manageSystemConfiguration();
