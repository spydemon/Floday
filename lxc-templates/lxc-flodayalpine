#!/usr/bin/env perl

use v5.010;
use warnings FATAL => 'all';
use strict;

#TODO: wired behavior with APKINDEX that doesnt't seems updated in some cases.

use Backticks;
use Carp;
use Config::Tiny;
use File::Slurp qw<read_file>;
use Floday::Helper::Config;
use Getopt::Long;
use List::Util qw<pairs>;
use Linux::LXC qw(ALLOW_UNDEF);

my $CONFIG = Floday::Helper::Config->instance();
my $CACHE_FOLDER = get_floday_configuration_value('cache_folder');
my $LOGGING_FOLDER = $CONFIG->get_floday_config('logging', 'metadata_folder');
my ($LXC_PATH, $LXC_NAME, $LXC_ROOTFS);
GetOptions("path=s" => \$LXC_PATH,
  "name=s" => \$LXC_NAME,
  "rootfs=s" => \$LXC_ROOTFS
);
my $LXC_UG_ID = get_user_id();

my %template_arguments= (@ARGV);

sub deploy_APK_index {
	if (!-d "$CACHE_FOLDER/apkIndex") {
		my $APK_archive = get_file('APKINDEX.tar.gz');
		`mkdir -p $CACHE_FOLDER/apkIndex`;
		`tar -xf $APK_archive -C $CACHE_FOLDER/apkIndex`;
	}
	return "$CACHE_FOLDER/apkIndex/APKINDEX";
}

sub generate_LXC_configuration{
	#TODO : Apply restriction by apparmor and seccomp.
	my $range = get_floday_configuration_value('id_range');
	open(my $configuration_file, '>', "$LXC_PATH/config");
	`touch $LXC_ROOTFS/dev/urandom`;
	say $configuration_file $_ for
	  "lxc.id_map = u 0 $LXC_UG_ID $range",
	  "lxc.id_map = g 0 $LXC_UG_ID $range",
	  "lxc.mount.auto = proc:mixed",
	  "lxc.mount.entry = $CACHE_FOLDER/apk $LXC_ROOTFS/etc/apk/cache none bind 0.0",
	  "lxc.mount.entry = $LOGGING_FOLDER $LXC_ROOTFS/$LOGGING_FOLDER none bind 0.0",
	  "lxc.mount.entry = /dev/urandom $LXC_ROOTFS/dev/urandom none bind",
	  "lxc.mount.entry = /dev/null $LXC_ROOTFS/dev/null none bind",
	  "lxc.network.type = veth",
	  "lxc.network.flags = up",
	  "lxc.network.link = lxcbr0",
	  "lxc.rootfs = $LXC_ROOTFS",
	  "lxc.start.auto = 1",
	  "lxc.utsname = $LXC_NAME"
}

sub get_alpine_version_to_use {
	$template_arguments{version} =~ /^[0-9]{1,2}\.[0-9]{1}$/
	  ? "v$template_arguments{version}"
	  : die "The version of alpine to use is mandatory";
}

sub get_architecture_to_use {
	$template_arguments{architecture} // 'x86_64';
}

sub get_file {
	my ($package_name) = @_;
	my $repository_address = get_main_repository_address() . '/' . get_architecture_to_use();
	my $path_for_downloaded_file = "$CACHE_FOLDER/files";
	-f "$path_for_downloaded_file/$package_name"
	  or `wget -q -P $path_for_downloaded_file $repository_address/$package_name`;
	return "$path_for_downloaded_file/$package_name";
}

sub get_floday_configuration_value {
	my ($attribute) = @_;
	state $config = Config::Tiny->read('/etc/floday/floday.cfg');
	my $property = $config->{lxc}->{$attribute};
	defined $property
	 or croak("The property lxc/$attribute was asked but is not defined in Floday configuration file");
	return $property;
}

sub get_package {
	my ($target) = @_;
	my $index = read_file(deploy_APK_index());
	while (
	  $index =~ /
	    ^P:(?P<name>.*)\n        #Get the next software name present in the index.
	    ^V:(?P<version>.*)\n     #Get the next software version present in the index.
	  /mgx
	) {
		if ($+{name} eq $target) {
			return get_file("$+{name}-$+{version}.apk");
		}
	}
	die("Package $target was not found in APKIndex");
}

#TODO: should be unit tested.
sub get_user_id {
	my @already_used_ugid =
	  map {Linux::LXC->new(utsname => $_)->get_config('lxc.id_map', qr/^u \d+ (\d+) (\d+)$/, ALLOW_UNDEF)}
	  grep {$_ ne $LXC_NAME}
	  Linux::LXC->get_existing_containers();
	my $range = get_floday_configuration_value('id_range');
	my $groups = get_floday_configuration_value('id_groups');
	REGENERATE_ID: for (1...10) {
		my @already_used_ugid_copy = @already_used_ugid;
		my $candidate_id = int(rand($groups)+1) * $range;
		foreach (pairs @already_used_ugid_copy) {
			my ($current_start_id, $current_range) = @$_;
			if ($current_start_id < ($candidate_id + $range) && $candidate_id < ($current_start_id + $current_range)) {
				next REGENERATE_ID;
			}
		}
		return $candidate_id;
	}
	die('10 id collisions occured with already existing LXC containers. Maybe should you increase lxc.id_groups?');
}

sub get_main_repository_address {
	'http://'
	  . $CONFIG->get_floday_config('lxc', 'repo')
	  . '/alpine/'
	  . get_alpine_version_to_use()
	  . '/main'
	;
}

sub init_system {
	my $apkRepoToUse = get_main_repository_address();
	my $arch = get_architecture_to_use();
	unless (-d "$CACHE_FOLDER/tmp") {
		`mkdir -p $CACHE_FOLDER/apk && chmod a+rw $CACHE_FOLDER/apk`
	}
	`ln -s $CACHE_FOLDER/apk $LXC_ROOTFS/etc/apk/cache `;
	`echo $apkRepoToUse > $LXC_ROOTFS/etc/apk/repositories`;
	#TODO: update of repo only when needed.
	`$LXC_ROOTFS/sbin/apk.static -U add --initdb --root $LXC_ROOTFS --arch $arch alpine-base`;
}

sub install_package {
	my ($packageName) = @_;
	my $packagePath = get_package($packageName);
	`tar -xf '$packagePath' -C '$LXC_ROOTFS' 2>/dev/null`;
	$packageName =~ s/\W//g;
	if (defined &{"_installPackage_$packageName"}) {
		no strict 'refs';
		&{"_installPackage_$packageName"}();
	}
}

sub manage_system_configuration {
	`rm -r $LXC_ROOTFS/etc/apk/cache && mkdir -p $LXC_ROOTFS/etc/apk/cache`;
	`mkdir -p $LXC_ROOTFS/$LOGGING_FOLDER`;
	`chmod 750 $LXC_PATH`;
	`chown :$LXC_UG_ID $LXC_PATH`;
	`chown -R $LXC_UG_ID:$LXC_UG_ID $LXC_ROOTFS`;
	my @init_tab = (
		'::sysinit:/sbin/openrc sysinit',
		'::sysinit:/sbin/openrc boot',
		'::wait:/sbin/openrc default',
		'::shutdown:/sbin/openrc shutdown'
	);
	open (my $inittab, '>', "$LXC_ROOTFS/etc/inittab");
	map {say $inittab $_} @init_tab;
}

sub _install_package_alpinekeys {
	my %keys = (
	  'v3.4' => {
	    'alpine-devel@lists.alpinelinux.org-4a6a0840.rsa.pub' => '9c102bcc376af1498d549b77bdbfa815ae86faa1d2d82f040e616b18ef2df2d4',
	    'alpine-devel@lists.alpinelinux.org-4d07755e.rsa.pub' => '2adcf7ce224f476330b5360ca5edb92fd0bf91c92d83292ed028d7c4e26333ab',
	    'alpine-devel@lists.alpinelinux.org-5243ef4b.rsa.pub' => 'ebf31683b56410ecc4c00acd9f6e2839e237a3b62b5ae7ef686705c7ba0396a9',
	    'alpine-devel@lists.alpinelinux.org-524d27bb.rsa.pub' => '1bb2a846c0ea4ca9d0e7862f970863857fc33c32f5506098c636a62a726a847b',
	    'alpine-devel@lists.alpinelinux.org-5261cecb.rsa.pub' => '12f899e55a7691225603d6fb3324940fc51cd7f133e7ead788663c2b7eecb00c',
	  },
	  'v3.5' => {
	    'alpine-devel@lists.alpinelinux.org-4a6a0840.rsa.pub' => '9c102bcc376af1498d549b77bdbfa815ae86faa1d2d82f040e616b18ef2df2d4',
	    'alpine-devel@lists.alpinelinux.org-4d07755e.rsa.pub' => '2adcf7ce224f476330b5360ca5edb92fd0bf91c92d83292ed028d7c4e26333ab',
	    'alpine-devel@lists.alpinelinux.org-5243ef4b.rsa.pub' => 'ebf31683b56410ecc4c00acd9f6e2839e237a3b62b5ae7ef686705c7ba0396a9',
	    'alpine-devel@lists.alpinelinux.org-524d27bb.rsa.pub' => '1bb2a846c0ea4ca9d0e7862f970863857fc33c32f5506098c636a62a726a847b',
	    'alpine-devel@lists.alpinelinux.org-5261cecb.rsa.pub' => '12f899e55a7691225603d6fb3324940fc51cd7f133e7ead788663c2b7eecb00c',
	    'alpine-devel@lists.alpinelinux.org-58199dcc.rsa.pub' => '73867d92083f2f8ab899a26ccda7ef63dfaa0032a938620eda605558958a8041'
	  }
	);
	my $key_list = `echo $LXC_ROOTFS/etc/apk/keys/*.pub`;
	my $key_checked = 0;
	while ($key_list =~ /
	    (?P<keyPathToUse>.*?                    #keyPathToUse will contain the absolute path of the next key.
	      (?P<keyNameToUse>alpine-devel.*?)     #keyNameToUse will contain only the name of the next key.
	    )
	  \s/gx
	) {
		die("Undefined key for $+{keyNameToUse}") unless defined $keys{get_alpine_version_to_use()}->{$+{keyNameToUse}};
		`cd $LXC_ROOTFS/etc/apk/keys && echo "$keys{get_alpine_version_to_use()}->{$+{keyNameToUse}} $+{keyNameToUse}" | sha256sum -c -`;
		$key_checked += 1;
	}
	die ('Too much key signatures are in this template') if ($key_checked != keys %{$keys{get_alpine_version_to_use()}});
}

sub _install_package_apktoolsstatic {
	`echo $LXC_ROOTFS/sbin/apk.static.*.pub`     #Get the path of the file corresponding to apk.static signed hash.
	  =~ /
	    (?P<signatureToCheck>^.*                 #Capture the absolute path without the \n at the end of the line.
	      (?P<keyToUse>alpine-devel[^\/]*)       #The name of the key used for the signature is present in the hash name.
	    )
	  \s$/x;
	my $file_to_check = "$LXC_ROOTFS/sbin/apk.static";
	my $key_to_use_for_checking = "$LXC_ROOTFS/etc/apk/keys/$+{keyToUse}";
	`openssl dgst -sha1 -verify $key_to_use_for_checking -signature $+{signatureToCheck} $file_to_check`;
}

install_package('alpine-keys');
install_package('apk-tools-static');
init_system();
generate_LXC_configuration();
manage_system_configuration();
